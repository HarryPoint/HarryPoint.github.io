---
tags: [算法]
---

## 树

> 一种`分层`数据的抽象模型
> js 中没有树，但可以用`Object`和`Array`构建树

### 树的深度优先遍历

> 尽可能深的搜索树的分支

![img](https://cdn.jsdelivr.net/gh/HarryPoint/oss@main/uPic/2022-03-11_13:10:15_sd.png)

- 访问根节点
- 对根节点的children 挨个进行深度优先遍历  

```js
const dfs = (root) => {
  console.log(root.val);
  root.children.forEach(dfs);
}
```



### 树的广度优先遍历

> 访问离根节点最近的节点

![img](https://cdn.jsdelivr.net/gh/HarryPoint/oss@main/uPic/2022-03-11_13:10:59_Mvrz19.png)

- 新建一个队列，把根节点入队
- 把对头出队并访问
- 把队头的children 挨个入队
- 重复第2、3步，直到队列为空

```js
const bfs = (root) => {
  const q = [root];
  while(q.length > 0) {
    const n = q.shift();
    console.log(n.val);
    n.children.forEach(child => {
      q.push(child);
    })
  }
} 
```



### 二叉树的先中后序遍历

#### 二叉树的先序遍历

![img](https://cdn.jsdelivr.net/gh/HarryPoint/oss@main/uPic/2022-03-11_13:29:10_xc8g2M.png)

- 访问根节点
- 对根节点的左子树进行先序遍历
- 对根节点的右子树进行先序遍历

```js
const preorder = (root) => {
  if(!root) return;
  console.log(root.val);
  preorder(root.left);
  preorder(root.right);
}
```

非递归版

```js
const preorder = (root) => {
  if(!root) return;
  const stack = [root];
  while(stack.length) {
    const n = stack.pop();
    console.log(n.val);
    if(n.right) stack.push(n.right);
    if(n.left) stack.push(n.left);
  }
} 
```



#### 二叉树的中序遍历

![img](https://cdn.jsdelivr.net/gh/HarryPoint/oss@main/uPic/2022-03-11_13:34:25_Il155f.png)

- 对根节点的左子树进行中序遍历
- 访问根节点
- 对根节点的右子树进行中序遍历

```js
const inorder = (root) => {
  if(!root) return;
  inorder(root.left);
  console.log(root.val);
  inorder(root.right);
}
```

非递归版

```js
const inorder = (root) => {
  if(!root) return;
  const stack = [];
  const p = root;
  while(stack.length || p) {
    while(p) {
      stack.push(p);
      p = p.left;
    }
    const n = stack.pop();
    console.log(n.val);
    p = n.right;
  }
}
```



#### 二叉树的后序遍历

![img](https://cdn.jsdelivr.net/gh/HarryPoint/oss@main/uPic/2022-03-11_13:39:33_2LqLwj.png)

- 对根节点的左子树进行后序遍历
- 对根节点的右子树进行后序遍历
- 访问根节点

```js
const postorder = (root) => {
  if(!root) return;
  postorder(root.left);
  postorder(root.right);
  console.log(root.val);
}
```

非递归版

```js
const postorder = (root) => {
  if(!root) return;
  const outputstack = [];
  const stack = [root];
  while(stack.length) {
    const n = stack.pop();
    outputstack.push(n);
    if(n.left) stack.push(n.left);
    if(n.right) stack.push(n.right);
  }
  while(outputstack.length) {
    const n = outputstack.pop();
    console.log(n.val);
  }
} 
```

